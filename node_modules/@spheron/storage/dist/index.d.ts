import { DomainTypeEnum, ProjectStateEnum, ProtocolEnum, UploadResult, PinStatus, IPNSName, TokenScope } from '@spheron/core';
export { DomainTypeEnum, IPNSName, ProtocolEnum, TokenScope } from '@spheron/core';
import { AuthSig, AccessControlConditions, EvmContractConditions, SolRpcConditions, UnifiedAccessControlConditions, Chain } from '@spheron/encryption';
export { uint8arrayToString } from '@spheron/encryption';

interface Domain {
    id: string;
    name: string;
    link: string;
    verified: boolean;
    bucketId: string;
    type: DomainTypeEnum;
}
type BucketStateEnum = ProjectStateEnum;
interface Bucket {
    id: string;
    name: string;
    organizationId: string;
    state: BucketStateEnum;
    domains: Domain[];
}
declare enum UploadStatusEnum {
    PENDING = "Pending",
    CANCELED = "Canceled",
    DEPLOYED = "Deployed",
    FAILED = "Failed",
    TIMED_OUT = "TimedOut"
}
interface Upload {
    id: string;
    protocolLink: string;
    buildDirectory: string[];
    status: UploadStatusEnum;
    memoryUsed: number;
    bucketId: string;
    protocol: string;
}
interface UsageWithLimits {
    used: {
        bandwidth: number;
        storageArweave: number;
        storageIPFS: number;
        domains: number;
        numberOfRequests: number;
        parallelUploads: number;
    };
    limit: {
        bandwidth: number;
        storageArweave: number;
        storageIPFS: number;
        domains: number;
        parallelUploads: number;
    };
}

declare const ipfs: {
    utils: {
        toV0: (v1: string) => string;
        toV1: (v0: string) => string;
    };
};

interface EncryptToIpfsProps {
    authSig?: AuthSig;
    sessionSigs?: any;
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain: Chain;
    string?: string;
    filePath?: string;
    litNodeClient: any;
    configuration: {
        name: string;
        onUploadInitiated?: (uploadId: string) => void;
        onChunkUploaded?: (uploadedSize: number, totalSize: number) => void;
    };
}
interface DecryptFromIpfsProps {
    authSig?: AuthSig;
    sessionSigs?: any;
    ipfsCid: string;
    litNodeClient: any;
}

interface SpheronClientConfiguration {
    token: string;
}
declare class SpheronClient {
    private readonly configuration;
    private readonly spheronApi;
    private readonly bucketManager;
    private readonly uploadManager;
    constructor(configuration: SpheronClientConfiguration);
    upload(path: string, configuration: {
        name: string;
        protocol: ProtocolEnum;
        organizationId?: string;
        onUploadInitiated?: (uploadId: string) => void;
        onChunkUploaded?: (uploadedSize: number, totalSize: number) => void;
    }): Promise<UploadResult>;
    encryptUpload({ authSig, sessionSigs, accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, chain, string, filePath, litNodeClient, configuration, }: EncryptToIpfsProps): Promise<UploadResult>;
    decryptUpload({ authSig, sessionSigs, ipfsCid, litNodeClient, }: DecryptFromIpfsProps): Promise<Uint8Array>;
    createSingleUploadToken(configuration: {
        name: string;
        protocol: ProtocolEnum;
    }): Promise<{
        uploadToken: string;
    }>;
    pinCID(configuration: {
        name: string;
        cid: string;
    }): Promise<{
        uploadId: string;
        bucketId: string;
        protocolLink: string;
        dynamicLinks: string[];
    }>;
    getBucket(bucketId: string): Promise<Bucket>;
    getCIDStatus(CID: string): Promise<{
        pinStatus: PinStatus;
    }>;
    getBucketDomains(bucketId: string): Promise<Domain[]>;
    getBucketDomain(bucketId: string, domainIdentifier: string): Promise<Domain>;
    addBucketDomain(bucketId: string, options: {
        link: string;
        type: DomainTypeEnum | "domain" | "subdomain" | "handshake-domain" | "handshake-subdomain" | "ens-domain";
        name: string;
    }): Promise<Domain>;
    updateBucketDomain(bucketId: string, domainIdentifier: string, options: {
        link: string;
        name: string;
    }): Promise<Domain>;
    verifyBucketDomain(bucketId: string, domainIdentifier: string): Promise<Domain>;
    getCdnDnsRecords(): Promise<{
        cdnARecords: string;
        cdnCnameRecords: string;
    }>;
    deleteBucketDomain(bucketId: string, domainIdentifier: string): Promise<void>;
    archiveBucket(bucketId: string): Promise<void>;
    unarchiveBucket(bucketId: string): Promise<void>;
    publishIPNS(uploadId: string): Promise<IPNSName>;
    updateIPNSName(ipnsNameId: string, uploadId: string): Promise<IPNSName>;
    getIPNSName(ipnsNameId: string): Promise<IPNSName>;
    getIPNSNamesForUpload(uploadId: string): Promise<IPNSName[]>;
    getIPNSNamesForOrganization(organizationId: string): Promise<IPNSName[]>;
    getBucketUploadCount(bucketId: string): Promise<{
        total: number;
        successful: number;
        failed: number;
        pending: number;
    }>;
    getBucketUploads(bucketId: string, options: {
        skip: number;
        limit: number;
    }): Promise<Upload[]>;
    getUpload(uploadId: string): Promise<Upload>;
    getOrganizationUsage(organizationId: string): Promise<UsageWithLimits>;
    getTokenScope(): Promise<TokenScope>;
}

export { Bucket, BucketStateEnum, Domain, SpheronClient, SpheronClientConfiguration, Upload, UploadStatusEnum, UsageWithLimits, SpheronClient as default, ipfs };
