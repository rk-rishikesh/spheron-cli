"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DomainTypeEnum: () => import_core.DomainTypeEnum,
  IPNSName: () => import_core2.IPNSName,
  ProtocolEnum: () => import_core2.ProtocolEnum,
  SpheronClient: () => SpheronClient,
  TokenScope: () => import_core2.TokenScope,
  UploadStatusEnum: () => UploadStatusEnum,
  default: () => src_default,
  ipfs: () => ipfs,
  uint8arrayToString: () => import_encryption.uint8arrayToString
});
module.exports = __toCommonJS(src_exports);

// src/bucket-manager/index.ts
var import_core = require("@spheron/core");

// src/bucket-manager/interfaces.ts
var UploadStatusEnum = /* @__PURE__ */ ((UploadStatusEnum2) => {
  UploadStatusEnum2["PENDING"] = "Pending";
  UploadStatusEnum2["CANCELED"] = "Canceled";
  UploadStatusEnum2["DEPLOYED"] = "Deployed";
  UploadStatusEnum2["FAILED"] = "Failed";
  UploadStatusEnum2["TIMED_OUT"] = "TimedOut";
  return UploadStatusEnum2;
})(UploadStatusEnum || {});

// src/bucket-manager/index.ts
var BucketManager = class {
  constructor(spheronApi) {
    this.spheronApi = spheronApi;
  }
  getBucket(bucketId) {
    return __async(this, null, function* () {
      const project = yield this.spheronApi.getProject(bucketId);
      if (project.type !== import_core.ProjectTypeEnum.UPLOAD) {
        throw new Error(`Project with id '${bucketId}' is not a bucket.`);
      }
      return this.mapProjectToBucket(project);
    });
  }
  getBucketDomains(bucketId) {
    return __async(this, null, function* () {
      const { domains } = yield this.spheronApi.getProjectDomains(bucketId);
      return domains.map((x) => this.mapProjectDomainToBucketDomain(x));
    });
  }
  getBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.getProjectDomain(
        bucketId,
        domainIdentifier
      );
      return this.mapProjectDomainToBucketDomain(domain);
    });
  }
  updateBucketDomain(bucketId, domainIdentifier, options) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.patchProjectDomain(
        bucketId,
        domainIdentifier,
        __spreadProps(__spreadValues({}, options), { deploymentEnvironments: [] })
      );
      return this.mapProjectDomainToBucketDomain(domain);
    });
  }
  verifyBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.verifyProjectDomain(
        bucketId,
        domainIdentifier
      );
      return this.mapProjectDomainToBucketDomain(domain);
    });
  }
  deleteBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      yield this.spheronApi.deleteProjectDomain(bucketId, domainIdentifier);
    });
  }
  addBucketDomain(bucketId, options) {
    return __async(this, null, function* () {
      const { domain } = yield this.spheronApi.addProjectDomain(bucketId, __spreadProps(__spreadValues({}, options), {
        deploymentEnvironments: []
      }));
      return this.mapProjectDomainToBucketDomain(domain);
    });
  }
  getBucketUploads(bucketId, options) {
    return __async(this, null, function* () {
      if (options.skip < 0 || options.limit < 0) {
        throw new Error(`Skip and Limit cannot be negative numbers.`);
      }
      const { deployments } = yield this.spheronApi.getProjectDeployments(
        bucketId,
        {
          skip: options.skip && options.skip >= 0 ? options.skip : 0,
          limit: options.limit && options.limit >= 0 ? options.limit : 6
        }
      );
      return deployments.map((x) => this.mapDeploymentToUpload(x));
    });
  }
  getBucketUploadCount(bucketId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.getProjectDeploymentCount(bucketId);
    });
  }
  archiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.spheronApi.updateProjectState(
        bucketId,
        import_core.ProjectStateEnum.ARCHIVED
      );
    });
  }
  unarchiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.spheronApi.updateProjectState(
        bucketId,
        import_core.ProjectStateEnum.MAINTAINED
      );
    });
  }
  getUpload(uploadId) {
    return __async(this, null, function* () {
      const deployment = yield this.spheronApi.getDeployment(uploadId);
      return this.mapDeploymentToUpload(deployment);
    });
  }
  mapProjectToBucket(project) {
    var _a;
    return {
      id: project._id,
      name: project.name,
      organizationId: project.organization,
      state: project.state,
      domains: (_a = project.domains) == null ? void 0 : _a.map(
        (x) => this.mapProjectDomainToBucketDomain(x)
      )
    };
  }
  mapProjectDomainToBucketDomain(domain) {
    return {
      id: domain._id,
      name: domain.name,
      link: domain.link,
      verified: domain.verified,
      bucketId: domain.projectId,
      type: domain.type
    };
  }
  mapDeploymentToUpload(deployment) {
    var _a, _b;
    return {
      id: deployment._id,
      protocolLink: deployment.sitePreview,
      buildDirectory: deployment.buildDirectory,
      status: deployment.status,
      memoryUsed: deployment.memoryUsed,
      bucketId: (_b = (_a = deployment.project) == null ? void 0 : _a._id) != null ? _b : deployment.project,
      protocol: deployment.protocol
    };
  }
};
var bucket_manager_default = BucketManager;

// src/index.ts
var import_core2 = require("@spheron/core");

// src/fs-payload-creator.ts
var import_fs = __toESM(require("fs"));
var import_form_data = __toESM(require("form-data"));
var import_path = __toESM(require("path"));
var createPayloads = (path2, payloadSize) => __async(void 0, null, function* () {
  const uploadContext = {
    payloads: new Array(),
    currentPayload: null,
    currentPayloadSize: 0,
    totalSize: 0
  };
  yield fillUploadContext(path2, "./", uploadContext, true, payloadSize);
  if (uploadContext.currentPayload) {
    uploadContext.payloads.push(uploadContext.currentPayload);
  }
  return {
    payloads: uploadContext.payloads,
    totalSize: uploadContext.totalSize
  };
});
var fillUploadContext = (pathToFile, rootPath, uploadContext, isRoot, payloadSize) => __async(void 0, null, function* () {
  const stat = yield import_fs.default.promises.stat(pathToFile);
  if (stat.isFile()) {
    const fileName = import_path.default.basename(pathToFile);
    processFile(
      pathToFile,
      rootPath + fileName,
      stat,
      uploadContext,
      payloadSize
    );
    return;
  }
  const files = yield import_fs.default.promises.readdir(pathToFile);
  for (const file of files) {
    yield fillUploadContext(
      `${pathToFile}/${file}`,
      isRoot ? "./" : `${rootPath}${import_path.default.basename(pathToFile)}/`,
      uploadContext,
      false,
      payloadSize
    );
  }
});
var processFile = (fullPath, uploadPath, stat, uploadContext, payloadSize) => __async(void 0, null, function* () {
  uploadContext.totalSize += stat.size;
  if (stat.size > payloadSize) {
    const numOfChunks = Math.ceil(stat.size / payloadSize);
    for (let i = 0; i < numOfChunks; i++) {
      const start = i * payloadSize;
      const end = start + payloadSize - 1;
      const form = new import_form_data.default();
      form.append(
        `chunk-${i}-${numOfChunks}`,
        import_fs.default.createReadStream(fullPath, { start, end }),
        {
          filepath: uploadPath
        }
      );
      uploadContext.payloads.push(form);
    }
  } else {
    if (!uploadContext.currentPayload) {
      uploadContext.currentPayload = new import_form_data.default();
    }
    uploadContext.currentPayload.append(
      "files",
      import_fs.default.createReadStream(fullPath),
      {
        filepath: uploadPath
      }
    );
    uploadContext.currentPayloadSize += stat.size;
    if (uploadContext.currentPayloadSize > payloadSize) {
      uploadContext.payloads.push(uploadContext.currentPayload);
      uploadContext.currentPayload = null;
      uploadContext.currentPayloadSize = 0;
    }
  }
});

// src/ipfs.utils.ts
var import_cid = require("multiformats/cid");
var ipfs = {
  utils: {
    toV0: (v1) => {
      const cid = import_cid.CID.parse(v1);
      if (cid.version === 0)
        return v1;
      return cid.toV0().toString();
    },
    toV1: (v0) => {
      const cid = import_cid.CID.parse(v0);
      if (cid.version === 1)
        return v0;
      return cid.toV1().toString();
    }
  }
};

// src/index.ts
var import_encryption = require("@spheron/encryption");

// src/utils.ts
var import_fs2 = __toESM(require("fs"));
function readFileContent(filePath) {
  return __async(this, null, function* () {
    const exists = import_fs2.default.promises.access(filePath, import_fs2.default.constants.F_OK);
    if (!exists) {
      throw new Error("File does not exist.");
    }
    const fileBuffer = yield import_fs2.default.promises.readFile(filePath);
    const fileContent = new Uint8Array(fileBuffer);
    return {
      content: fileContent
    };
  });
}

// src/index.ts
var import_form_data2 = __toESM(require("form-data"));
var SpheronClient = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.spheronApi = new import_core2.SpheronApi(this.configuration.token);
    this.bucketManager = new bucket_manager_default(this.spheronApi);
    this.uploadManager = new import_core2.UploadManager();
  }
  upload(path2, configuration) {
    return __async(this, null, function* () {
      const { deploymentId, payloadSize, parallelUploadCount } = yield this.uploadManager.initiateDeployment({
        protocol: configuration.protocol,
        name: configuration.name,
        organizationId: configuration.organizationId,
        token: this.configuration.token
      });
      let success = true;
      let caughtError = void 0;
      try {
        const { payloads, totalSize } = yield createPayloads(path2, payloadSize);
        configuration.onUploadInitiated && configuration.onUploadInitiated(deploymentId);
        const uploadPayloadsResult = yield this.uploadManager.uploadPayloads(
          payloads,
          {
            deploymentId,
            token: this.configuration.token,
            parallelUploadCount,
            onChunkUploaded: (uploadedSize) => configuration.onChunkUploaded && configuration.onChunkUploaded(uploadedSize, totalSize)
          }
        );
        if (!uploadPayloadsResult.success) {
          throw new Error(uploadPayloadsResult.errorMessage);
        }
      } catch (error) {
        success = false;
        caughtError = error;
      }
      const result = yield this.uploadManager.finalizeUploadDeployment(
        deploymentId,
        success,
        this.configuration.token
      );
      if (caughtError) {
        throw caughtError;
      }
      if (!result.success) {
        throw new Error(`Upload failed. ${result.message}`);
      }
      return {
        uploadId: result.deploymentId,
        bucketId: result.projectId,
        protocolLink: result.sitePreview,
        dynamicLinks: result.affectedDomains,
        cid: result.cid
      };
    });
  }
  encryptUpload(_0) {
    return __async(this, arguments, function* ({
      authSig,
      sessionSigs,
      accessControlConditions,
      evmContractConditions,
      solRpcConditions,
      unifiedAccessControlConditions,
      chain,
      string,
      filePath,
      litNodeClient,
      configuration
    }) {
      if (!string && !filePath) {
        throw new Error(`Either string or filePath must be provided`);
      }
      if (!configuration.name) {
        throw new Error(`Name must be provided`);
      }
      let dataToEncrypt = null;
      if (string && filePath) {
        throw new Error(`Provide only either a string or filePath to encrypt`);
      } else if (string !== void 0) {
        dataToEncrypt = (0, import_encryption.uint8arrayFromString)(string, "utf8");
      } else if (filePath !== void 0) {
        const { content } = yield readFileContent(filePath);
        dataToEncrypt = content;
      } else {
        throw new Error(`Either string or file must be provided`);
      }
      if (!dataToEncrypt) {
        throw new Error(`No data to encrypt`);
      }
      const { encryptedData, symmetricKey } = yield (0, import_encryption.encryptData)(dataToEncrypt);
      const encryptedSymmetricKey = yield litNodeClient.saveEncryptionKey({
        accessControlConditions,
        evmContractConditions,
        solRpcConditions,
        unifiedAccessControlConditions,
        symmetricKey,
        authSig,
        sessionSigs,
        chain
      });
      const encryptedSymmetricKeyString = (0, import_encryption.uint8arrayToString)(
        encryptedSymmetricKey,
        "base16"
      );
      const encryptedDataJson = Buffer.from(encryptedData.buffer).toJSON();
      try {
        const uploadJson = JSON.stringify({
          encryptedData: encryptedDataJson,
          encryptedSymmetricKeyString,
          accessControlConditions,
          evmContractConditions,
          solRpcConditions,
          unifiedAccessControlConditions,
          chain
        });
        const { deploymentId, parallelUploadCount } = yield this.uploadManager.initiateDeployment({
          protocol: import_core2.ProtocolEnum.IPFS,
          name: configuration.name,
          token: this.configuration.token
        });
        configuration.onUploadInitiated && configuration.onUploadInitiated(deploymentId);
        let success = true;
        let caughtError = void 0;
        const totalSize = Buffer.byteLength(uploadJson, "utf8");
        try {
          const form = new import_form_data2.default();
          form.append("files", uploadJson, "data.json");
          const uploadPayloadsResult = yield this.uploadManager.uploadPayloads(
            [form],
            {
              deploymentId,
              token: this.configuration.token,
              parallelUploadCount,
              onChunkUploaded: (uploadedSize) => configuration.onChunkUploaded && configuration.onChunkUploaded(uploadedSize, totalSize)
            }
          );
          if (!uploadPayloadsResult.success) {
            throw new Error(uploadPayloadsResult.errorMessage);
          }
        } catch (error) {
          success = false;
          caughtError = error;
        }
        const result = yield this.uploadManager.finalizeUploadDeployment(
          deploymentId,
          success,
          this.configuration.token
        );
        if (caughtError) {
          throw caughtError;
        }
        if (!result.success) {
          throw new Error(`Upload failed. ${result.message}`);
        }
        return {
          uploadId: result.deploymentId,
          bucketId: result.projectId,
          protocolLink: result.sitePreview,
          dynamicLinks: result.affectedDomains,
          cid: result.cid
        };
      } catch (e) {
        throw new Error(`Upload failed: ${e.message}`);
      }
    });
  }
  decryptUpload(_0) {
    return __async(this, arguments, function* ({
      authSig,
      sessionSigs,
      ipfsCid,
      litNodeClient
    }) {
      const metadata = yield (yield fetch(`https://${ipfsCid}.ipfs.sphn.link/data.json`).catch(() => {
        throw new Error("Error finding metadata from IPFS CID");
      })).json();
      const symmetricKey = yield litNodeClient.getEncryptionKey({
        accessControlConditions: metadata.accessControlConditions,
        evmContractConditions: metadata.evmContractConditions,
        solRpcConditions: metadata.solRpcConditions,
        unifiedAccessControlConditions: metadata.unifiedAccessControlConditions,
        toDecrypt: metadata.encryptedSymmetricKeyString,
        chain: metadata.chain,
        authSig,
        sessionSigs
      });
      const encrypted = new Uint8Array(Buffer.from(metadata.encryptedData));
      return (0, import_encryption.decryptData)(encrypted, symmetricKey);
    });
  }
  createSingleUploadToken(configuration) {
    return __async(this, null, function* () {
      const { singleDeploymentToken } = yield this.uploadManager.initiateDeployment({
        protocol: configuration.protocol,
        name: configuration.name,
        token: this.configuration.token,
        createSingleDeploymentToken: true
      });
      return { uploadToken: singleDeploymentToken };
    });
  }
  pinCID(configuration) {
    return __async(this, null, function* () {
      const { deploymentId, projectId, sitePreview, affectedDomains } = yield this.uploadManager.pinCID({
        name: configuration.name,
        token: this.configuration.token,
        cid: configuration.cid
      });
      return {
        uploadId: deploymentId,
        bucketId: projectId,
        protocolLink: sitePreview,
        dynamicLinks: affectedDomains
      };
    });
  }
  getBucket(bucketId) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucket(bucketId);
    });
  }
  getCIDStatus(CID2) {
    return __async(this, null, function* () {
      return yield this.uploadManager.getCIDStatus(CID2);
    });
  }
  getBucketDomains(bucketId) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucketDomains(bucketId);
    });
  }
  getBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucketDomain(bucketId, domainIdentifier);
    });
  }
  addBucketDomain(bucketId, options) {
    return __async(this, null, function* () {
      return yield this.bucketManager.addBucketDomain(bucketId, options);
    });
  }
  updateBucketDomain(bucketId, domainIdentifier, options) {
    return __async(this, null, function* () {
      return yield this.bucketManager.updateBucketDomain(
        bucketId,
        domainIdentifier,
        options
      );
    });
  }
  verifyBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      return yield this.bucketManager.verifyBucketDomain(
        bucketId,
        domainIdentifier
      );
    });
  }
  getCdnDnsRecords() {
    return __async(this, null, function* () {
      const { recordIpv4V2, recordCnameV2 } = yield this.spheronApi.getCdnRecords();
      return {
        cdnARecords: recordIpv4V2,
        cdnCnameRecords: recordCnameV2
      };
    });
  }
  deleteBucketDomain(bucketId, domainIdentifier) {
    return __async(this, null, function* () {
      return yield this.bucketManager.deleteBucketDomain(
        bucketId,
        domainIdentifier
      );
    });
  }
  archiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.bucketManager.archiveBucket(bucketId);
    });
  }
  unarchiveBucket(bucketId) {
    return __async(this, null, function* () {
      yield this.bucketManager.unarchiveBucket(bucketId);
    });
  }
  publishIPNS(uploadId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.publishIPNS(uploadId);
    });
  }
  updateIPNSName(ipnsNameId, uploadId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.updateIPNSName(ipnsNameId, uploadId);
    });
  }
  getIPNSName(ipnsNameId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.getIPNSName(ipnsNameId);
    });
  }
  getIPNSNamesForUpload(uploadId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.getIPNSNamesForUpload(uploadId);
    });
  }
  getIPNSNamesForOrganization(organizationId) {
    return __async(this, null, function* () {
      return yield this.spheronApi.getIPNSNamesForOrganization(organizationId);
    });
  }
  getBucketUploadCount(bucketId) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucketUploadCount(bucketId);
    });
  }
  getBucketUploads(bucketId, options) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getBucketUploads(bucketId, options);
    });
  }
  getUpload(uploadId) {
    return __async(this, null, function* () {
      return yield this.bucketManager.getUpload(uploadId);
    });
  }
  getOrganizationUsage(organizationId) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      const usage = yield this.spheronApi.getOrganizationUsage(
        organizationId,
        "wa-global"
      );
      return {
        used: {
          bandwidth: (_a = usage.usedBandwidth) != null ? _a : 0,
          storageArweave: (_b = usage.usedStorageArweave) != null ? _b : 0,
          storageIPFS: (_c = usage.usedStorageIPFS) != null ? _c : 0,
          domains: (_d = usage.usedDomains) != null ? _d : 0,
          numberOfRequests: (_e = usage.usedNumberOfRequests) != null ? _e : 0,
          parallelUploads: (_f = usage.usedParallelUploads) != null ? _f : 0
        },
        limit: {
          bandwidth: (_g = usage.bandwidthLimit) != null ? _g : 0,
          storageArweave: (_h = usage.storageArweaveLimit) != null ? _h : 0,
          storageIPFS: (_i = usage.storageIPFSLimit) != null ? _i : 0,
          domains: (_j = usage.domainsLimit) != null ? _j : 0,
          parallelUploads: (_k = usage.parallelUploadsLimit) != null ? _k : 0
        }
      };
    });
  }
  getTokenScope() {
    return __async(this, null, function* () {
      return yield this.spheronApi.getTokenScope();
    });
  }
};
var src_default = SpheronClient;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DomainTypeEnum,
  IPNSName,
  ProtocolEnum,
  SpheronClient,
  TokenScope,
  UploadStatusEnum,
  ipfs,
  uint8arrayToString
});
